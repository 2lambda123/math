
\part*{Appendices}
\addcontentsline{toc}{part}{Appendices}


\chapter{Licensing}

\noindent
\Stan and its two dependent libraries, Boost and Eigen, are
distributed under liberal licenses approved by the Open Source
Initiative.  In particular, these licenses have no ``copyleft''
provisions requiring applications of \Stan to be open source if they
are redistributed.

This chapter describes the licenses for the tools that are distributed
with \Stan.  The next chapter explains some of the build tools that
are not distributed with \Stan, but are required to build and run
\Stan models.


\section{\Stan's License}

\Stan is distributed under the BSD 3-clause license (BSD New).
%
\begin{quote}
\url{http://www.opensource.org/licenses/BSD-3-Clause}
\end{quote}

\section{Boost License}

Boost is distributed under the Boost Software
License version 1.0.
%
\begin{quote}
\url{http://www.opensource.org/licenses/BSL-1.0}
\end{quote}

\section{Eigen License} 
%
Eigen is distributed under the Mozilla Public License,
version 2.
%
\begin{quote}
\url{http:/http://opensource.org/licenses/mpl-2.0}
\end{quote}

\section{Google Test License}

\Stan uses Google Test for unit testing; it is not required to compile
or execute models.  Google Test is distributed under the BSD 2-clause
license.
%
\begin{quote}
\url{http://www.opensource.org/licenses/BSD-License}
\end{quote}


\chapter{Installation and Compatibility}\label{install.appendix}

\noindent
This appendix describes the hardware and software required to run
\Stan.  The software includes \Stan and its libraries, as well as a
contemporary \Cpp compiler.  \Stan requires hardware powerful enough
to build and execute the models.  Ideally, that will be a 64-bit
computer with at least 4GB of memory and multiple processor cores.

\section{Operating System}

\Stan is written in portable \Cpp without {\Cpp}11 features, as are the
libraries on which it depends.  Therefore, \Stan should run on any machine
for which a suitable \Cpp compiler is available.  In practice, \Stan,
like the Boost and Eigen libraries on which it depends, is very hard
on the compiler and linker.

\Stan has been tested on the following operating systems.
%
\begin{itemize}
\item Linux (Debian, Ubuntu, Red Hat), 
\item Mac OS X (Snow Leopard, Lion), and
\item Windows (XP, 7).
\end{itemize}
%
\Stan should work on other versions of these operating systems if
compatible \Cpp compilers can be found.  The plan is to keep up with
new versions of these operating systems and gradually phase out
testing on older versions.


\section{Requirements}

The only two absolute requirements for running \Stan are the
\Stan source code (and dependent libraries) and a \Cpp compiler.

\subsection{\Stan Source}

In order to compile \Stan models, the \Stan source code is required.
The latest version of \Stan can be downloaded from the following link.
%
\begin{quote}
\url{http://mc-stan.org/}
\end{quote}
%
The \Stan source code distribution includes \Stan's source code,
documentation, build tools, unit tests, demo models, documentation and
source for the required libraries Boost and Eigen, and the source for
an optional testing library, Google Test.

\subsubsection{Boost C++ Library Source}

\Stan's parser and some of its mathematical functions and 
template metaprogramming facilities are implemented with the Boost
\Cpp Library.  
%
\begin{itemize}
\item Home: http://www.boost.org/users/license.html
\item License: Boost Software License
\item Tested Version: 1.51.0
\end{itemize}
%
The Boost source code is distributed with \Stan.


\subsubsection{Eigen Matrix and Linear Algebra Library Source}

\Stan's matrix algebra depends on the Eigen \Cpp matrix and linear
algebra library.  
%
\begin{itemize}
\item Home: \url{http://eigen.tuxfamily.org}
\item License: LGPL3+
\item Tested Version: 3.1.0
\end{itemize}
%
The Eigen source code is distributed with \Stan.


\subsection{\Cpp Compiler}

Compiling \Stan models requires a \Cpp compiler.  \Stan has been
primarily developed with \clang and \gpp and no promises are made for
other compilers.  The full set of compilers for which \Stan has been
tested is
%
\begin{itemize}
%
\item \gpp
\\
Tested Versions: Mac 4.2.1, 4.6, Linux 4.4--4.7, Windows 4.6.3
\\
Home: \url{http://gcc.gnu.org/}
\\
License: GPL3+
%
\item \clang, Mac 2.9--3.1, Linux 2.9--3.1
\\
Home: \url{http://clang.llvm.org/}
\\
License: BSD
%
\item mingw-64, version 2.0 (Windows 7, cross-compiled from Debian Linux)
%
\item Intel \Cpp, Linux version 12.1.3
%
\end{itemize}
%

\section{Optional Components for Developers}

\Stan is developed using the following set of tools.  The various
command examples in this manual have assumed they can be found on
the command path.  The makefile allows precise locations to be plugged
in. 

\subsection{GNU Make Build Tool}

\Stan automates the build, test, documentation, and deployment tasks
using scripts in the form of makefiles to run with GNU Make.
%
\begin{itemize}
\item Home: \url{http://www.gnu.org/software/make}
\item License: GPLv3+
\item Tested Versions: 3.81 (Mac OS X), 3.79 (Windows 7)
\end{itemize}
%


\subsection{Doxygen Documentation Generator}

\Stan's API documentation is generated using the Doxygen Tool.
%
\begin{itemize}
\item Home: \url{http://www.stack.nl/~dimitri/doxygen/index.html}
\item License: GPL2
\item Tested Version(s): Mac OS X 1.8.2, Windows 1.8.2
\end{itemize}


\subsection{Git Version Control System}

\Stan uses the Git version control system for its software, libraries,
and documentations.  Git is required to interact with the most recent
versions of code in the version control repository.
% 
\begin{itemize}
\item Home: \url{http://git-scm.com/}
\item License: GPL2
\item Tested Version(s): Mac version 1.7.8.4, Windows version 1.7.9
\end{itemize}


\subsubsection{Google Test C++ Testing Framework}

\Stan's unit testing is based on the Google's googletest \Cpp testing
framework.  
%
\begin{itemize}
\item
Home: \url{http://code.google.com/p/googletest/}
\item
License: BSD
\item
Tested Version(s): 1.6.0
\end{itemize}
%
The Google Test framework is distributed with \Stan.


\section{Tips for Mac OS X}

\subsection{Install Xcode}

Apple's Xcode contains both the \clang and \gpp compilers and make, all of the tools 
needed to work with \Stan as a user. The version of Xcode to install depends on the
version of Mac OS X.

\begin{description}
\item[Mac OS X ``Snow Leopard'' or earlier]
Xcode 3: Good luck; we couldn't find it
\item[Mac OS X ``Lion'' or later]
Xcode 4: \url{https://developer.apple.com/xcode/}
\end{description}

Then, once you've installed Xcode, you need to start it, then open
menu option \code{Xcode}, select \code{Preferences}, then click on the
\code{Downloads} icon and then click on the \code{Install} button next
to the option labeled ``Command Line Tools.''

At this point, you should have the make system \code{make} and the two
\Cpp compilers/linkers, \gpp and \clang, installed.  This is all you
need to run \Stan.  Xcode will also install the \code{git} version
control system at this point.

\subsection{More Recent Compilers}

MacPorts hosts recent versions of compilers for the Macintosh.
%
\begin{quote}
\url{https://distfiles.macports.org/MacPorts/}
\end{quote}
%
After finding the appropriate \code{.dmg} file, clicking on it, then
double clicking on the resulting \code{.pkg} file, and clicking
through some more menus, the following will need to be entered from a
terminal window to install it.
%
\begin{quote}
\code{> sudo port install {\slshape gccVersion}}
\end{quote}
%
In this command, {\slshape gccVersion} is the name of a compiler
version, such as \code{g++=mp-4.6}, for version 4.6.  Errors may arise
during the install such as the following.
%
\begin{quote}\small\tt
  Error: Target org.macports.activate returned: Image error:
  /opt/local/include/gmp.h already exists and does not belong to a
  registered port.  Unable to activate port gmp. Use 'port -f activate
  gmp' to force the activation.
\end{quote}
%
This issue can be resolved by running the following command.
%
\begin{quote}
\code{> sudo port -f activate gmp}
\end{quote}
%


\subsection{Git Installer}

A standalone version of Git for Mac OS X is available from the
following site. 
%
\begin{quote}
\url{http://code.google.com/p/git-osx-installer/}
\end{quote}
%
Although (at the time of this writing) there were only versions listed
up to OS X version ``Snow Leopard,'' they work on ``Lion''.

\subsection{\LaTeX\ Typesetting Package}

\Stan uses the \LaTeX\ typesetting package for generating manuals,
talks, and other materials (Doxygen is used for API documentation; see
below).  The first step is to download the MacTeX \code{.mpkg} file
from the following URL [warning: the download is approximately 2GB and
the installation approximately 3.5GB].
%
\begin{quote}
\url{http://www.tug.org/mactex/2011/}
\end{quote}
%
Once it is downloaded, just click on the \code{.mpkg} file and then
follow the installer instructions.  The installer will add the command
to the \code{PATH} environment variable so that the \code{pdflatex}
used by \Stan is available from the command line.


\subsection{Lucida Console Font}

A free TrueType version of Lucida Console for the Mac is available
at the following URL.
%
\begin{quote}
\url{http://www.fontpalace.com/font-details/Lucida+Console/}
\end{quote}
%
Download the \code{.ttf} file, then click on it to install.  It
will then be available as a preference in the Mac terminal application.

\subsection{Doxygen API Documentation}

\Stan's API documentation is generated using the Doxygen tool.   This
tool is available from
%
\begin{quote}
\url{http://www.doxygen.org}
\end{quote}
%
Select the \code{Download} link from the second of the right-hand side
navigation bars, then select the binary distribution \code{.dmg} file
for Mac OS X.  Clicking on the \code{.dmg} file opens the finder with
a view of the unpacked Doxygen executable.  Just drag the Doxygen icon
into the Applications folder (or wherever you want to keep it).  Then
add the path to the Doxygen executable, 
%
\begin{quote}
\url{/Applications/Doxygen.app/Contents/Resources/doxygen}
\end{quote}
%
to the system \code{PATH} environment variable.  You can do add to the
\code{PATH} environment by adding this line to the end of the
top-level \Verb|~/.profile| file.  
%
\begin{quote}
\begin{Verbatim}
export PATH=/Applications/Doxygen.app/Contents/Resources:$PATH
\end{Verbatim}
\end{quote}
%
The next shell started will then be able to find the \code{doxygen} command.


\section{Tips for Windows}

\subsection{Install Rtools}

The easiest way to get a complete \Cpp build environment on Windows is
to install the most recent version of Rtools.  

The latest version verified to work with \Stan is Rtools 2.15.  Rtools
2.15 includes the \gpp 4.6.3 (pre-release) compiler and many other
useful command line tools including many Unix commands, such as the
following.
%
\begin{quote}
\tt basename, cat, cmp, comm, cp, cut, date,
diff, du, echo, expr, gzip, ls, make, makeinfo, mkdir, mv, rm, rsync,
sed, sh, sort, tar, texindex, touch, uniq
\end{quote}

Rtools can be downloaded from the following location.
%
\begin{quote}
  \url{http://cran.r-project.org/bin/windows/Rtools/}
\end{quote}
%
Install it using the Windows installer.  Allow it to edit the
\code{PATH} environment variable so that commands are available from
the command tool.

To verify the installation was successful, open a command window by
selecting the following menu items.
%
\begin{quote}
  \code{Start} 
  $\rightarrow$ Accessories 
  $\rightarrow$ Command Prompt
\end{quote}
%
To verify that \gpp is installed, use the following command.
%
\begin{quote}
  \Verb|> g++ -v|
\end{quote}
%
This should report version information for \gpp.  Next, verify that
\code{make} is installed with the following command.
%
\begin{quote}
  \Verb|> make -v|
\end{quote}
%
This should print version information for make.

\subsection{Install Git}

There are a number of Git clients for Windows that will work.  The
official Git installer for Windows can be found at the following
location.
%
\begin{quote}
\url{http://code.google.com/p/msysgit/downloads}
\end{quote}
%
Select the latest full installer and install it. 

\chapter{Stan for Users of BUGS}\label{stan-for-bugs.appendix}

From the outside, Stan and \BUGS%
%
\footnote{Except where otherwise noted, we use ``\BUGS'' to refer to
  Win\BUGS, Open\BUGS, and \JAGS, indiscriminately.}
%
are similar --- they use statistically-themed modeling languages
(which are similar but with some differences; see below), they can be
called from R, running some specified number of chains to some
specified length, producing posterior simulations that can be assessed
using standard convergence diagnostics.  This is not a coincidence:
in designing Stan, we wanted to keep many of the useful features of
Bugs.

To start, take a look at the files of translated \BUGS models at
\url{http://mc-stan.org/}.  These are 40 or so models from the \BUGS
example volumes, all translated and tested (to provide the same
answers as \BUGS) in Stan.  For any particular model you want to fit,
you can look for similar structures in these examples.

\section{Some Differences in How BUGS and Stan Work}

\begin{itemize}
\item \BUGS is interpreted; Stan is compiled in two steps, first a
  model is is translated to templated C++ and then to a
  platform-specific executable.  \Stan, unlike \BUGS, allows the user
  to directly program in C++, but we do not describe how to do this in
  this Stan manual (see the getting started with \Cpp section of
  \url{http://mc-stan.org} for more information on using Stan directly
  from \Cpp). 
\item \BUGS performs \MCMC updating one scalar parameter at a time
  (with some exceptions such as \JAGS's implementation of regression
  and generalized linear models and some conjugate multivariate
  parameters), using conditional distributions (Gibbs sampling) where
  possible and otherwise using adaptive rejection sampling, slice
  sampling, and Metropolis jumping.  \BUGS figures out the dependence
  structure of the joint distribution as specified in its modeling
  language and uses this information to compute only what it needs at
  each step.  Stan moves in the entire space of all the parameters
  using Hamiltonian Monte Carlo (more precisely, the no-U-turn
  sampler), thus avoiding some difficulties that occur with
  one-dimension-at-a-time sampling in high dimensions but at the cost
  of requiring the computation of the entire log density at each step.
\item \BUGS tunes its adaptive jumping (if necessary) during its
  warmup phase (traditionally referred to as "burn-in").  Stan uses
  its warmup phase to tune the no-U-turn sampler (\NUTS).
\item The \BUGS modeling language is not directly executable.  Rather,
  \BUGS parses its model to determine the posterior density and then
  decides on a sampling scheme.  In contrast, the statements in a Stan
  model are directly executable: they translate exactly into C++ code
  that is used to compute the log posterior density (which in turn is
  used to compute the gradient).
\item Stan uses its own \Cpp algorithmic differentiation packages to
  compute the gradient of the log density (up to a proportion).
  Gradients are required during the Hamiltonian dynamics simulations
  within the leapfrog algorithm of the Hamiltonian Monte Carlo and
  \NUTS samplers.  \BUGS computes the log density but not its
  gradient.
\item Both \BUGS and Stan are semi-automatic in that they run by
  themselves with no outside tuning required. Nevertheless, the user
  needs to pick the number of chains and number of iterations per
  chain.  We usually pick 4 chains and start with 10 iterations per
  chain (to make sure there are no major bugs and to approximately
  check the timing), then go to 100, 1000, or more iterations as
  necessary.  Compared to Gibbs or Metropolis, Hamiltonian Monte Carlo
  can take longer per iteration (as it typically takes many "leapfrog
  steps" within each iteration), but the iterations typically have lower
  autocorrelation.  So Stan might work fine with 1000 iterations in an
  example where \BUGS would require 100,000 for good mixing.  We 
  recommend monitoring potential scale reduction statistics ($\hat{R}$)
  and the effective sample size to judge when to stop (stopping when
  $\hat{R}$ values do not counterindicate convergence and when enough
  effective samples have been collected).
\item WinBUGS is closed source.  OpenBUGS and JAGS are both licensed
  under the Gnu Public License (GPL), otherwise known as copyleft due
  to the restrictions it places on derivative works.  Stan is licensed
  under the much more liberal new BSD license.
\item Like WinBUGS, OpenBUGS and JAGS, Stan can be run directly from
  the command line or through R (Python and MATLAB interfaces are in
  the works)
\item Like OpenBUGS and JAGS, Stan can be run on Linux, Mac, and
  Windows platforms.
\end{itemize}

\section{Some Differences in the Modeling Languages}

\begin{itemize}
\item The \BUGS modeling language follows an R-like syntax in which
  line breaks are meaningful.  Stan follows the rules of C, in which
  line breaks are equivalent to spaces, and each statement ends in a
  semicolon.  For example:
%
\begin{quote}
\begin{Verbatim}
y ~ normal(mu, sigma);
\end{Verbatim}
\end{quote}
%
and
%
\begin{quote}
\begin{Verbatim}
for (i in 1:n) y[i] ~ normal(mu, sigma);
\end{Verbatim}
\end{quote}
%
Or, equivalently (recall that a line break is just another form of whitespace),
%
\begin{quote}
\begin{Verbatim}
for (i in 1:n)
  y[i] ~ normal(mu, sigma);
\end{Verbatim}
\end{quote}
%
and also equivalently, 
%
\begin{quote}
\begin{Verbatim}
for (i in 1:n) {
  y[i] ~ normal(mu, sigma);
}
\end{Verbatim}
\end{quote}
%
There's a semicolon after the model statement but not after the
brackets indicating the body of the for loop.
%
\item Another C thing: In Stan, variables can have names constructed
  using letters, numbers, and the underscore (\code{\_}) symbol, but
  nothing else (and a variable name cannot begin with a number).
  \BUGS variables can also include the dot, or period (\code{.}) symbol.
%
\item In Stan, the second argument to the "normal" function is the
  standard deviation (i.e., the scale), not the variance (as in {\it
    Bayesian Data Analysis}) and not the inverse-variance (i.e.,
  precision) (as in \BUGS).  Thus a normal with mean 1 and standard
  deviation 2 is \code{normal(1,2)}, not \code{normal(1,4)} or
  \code{normal(1,0.25)}.
%
\item
The distributions have slightly different names:
%
\begin{quote}
\begin{tabular}{l|l}
{\it BUGS} & {\it Stan} \\ \hline \hline
\code{dnorm} & \code{normal} \\
\code{dbinom} & \code{binomial} \\
\code{dpois} & \code{poisson} \\
$\vdots$ & $\vdots$
\end{tabular}
\end{quote}
%
\item Stan, unlike \BUGS, allows intermediate quantities, in the form
  of local variables, to be reassigned.  For example, the following is
  legal and meaningful (if possibly inefficient) Stan code.
%
\begin{quote}
\begin{Verbatim}
{
  total <- 0;
  for (i in 1:n){
    theta[i] ~ normal(total, sigma);
    total <- total + theta[i];
  }
}
\end{Verbatim}
\end{quote}
%
In \BUGS, the above model would not be legal because the variable
\code{total} is defined more than once.  But in Stan, the loop is
executed in order, so \code{total} is overwritten in each step.  
%
\item Stan uses explicit declarations.  Variables are declared with
  base type integer or real, and vectors, matrices, and arrays have
  specified dimensions.  When variables are bounded, we give that
  information also.  For data and transformed parameters, the bounds
  are used for error checking.  For parameters, the constraints
  are critical to sampling as they determine the geometry over which
  the Hamiltonian is simulated.  
  \\[6pt]
  Variables can be declared as data, transformed data, parameters, transformed
  parameters, or generated quantities.  They can also be declared as
  local variables within blocks.  For more information, see
  the part of this manual devoted to the Stan programming language and
  examine at the example models.
%
\item Stan allows all sorts of tricks with vector and matrix
  operations which can make Stan models more compact.  For example,
  arguments to probability functions may be vectorized,%
%
\footnote{So far, very few distributions have been vectorized, but
eventually all of them will be vectorized.}
%
allowing
%
\begin{quote}
\begin{Verbatim}
for (i in 1:n) 
  y[i] ~ normal(mu[i], sigma[i]);
\end{Verbatim}
\end{quote}
%
to be expressed more compactly as 
%
\begin{quote}
\begin{Verbatim}
y ~ normal(mu,sigma);
\end{Verbatim}
\end{quote}
%
The vectorized form is also more efficient because Stan can unfold the
computation of the chain rule during algorithmic differentiation.
%
\item Stan also allows for arrays of vectors and matrices.
  For example, in a hierarchical model might have a vector of \code{K}
  parameters for each of \code{J} groups; this can be declared using
\begin{quote}
\begin{Verbatim}
vector[K] theta[J];
\end{Verbatim}
\end{quote}
%
Then \code{theta[j]} is an expression denoting a \code{K}-vector and
may be used in the code just like any other vector variable.
\\[6pt]
An alternative encoding would be with a two-dimensional array, as in
\begin{quote}
\begin{Verbatim}
real theta[J,K];
\end{Verbatim}
\end{quote}
%
The vector version can have some advantages, both in convenience and
in computational speed for some operations.
\\[6pt]
A third encoding would use a matrix:
%
\begin{quote}
\begin{Verbatim}
matrix[J,K] theta;
\end{Verbatim}
\end{quote}
%
but in this case, \code{theta[j]} is a row vector, not a vector, and
accessing it as a vector is less efficient than with an array of
vectors.  The transposition operator, as in \code{theta[j]'}, may be
used to convert the row vector \code{theta[j]} to a (column) vector.
Column vector and row vector types are not interchangeable everywhere
in Stan; see the function signature declarations in the programming
language section of this manual.
\end{itemize}

\section{Some Differences in the Statistical Models that are Allowed}

\begin{itemize}
\item Stan does not yet support sampling discrete parameters (discrete
  data is supported).  We plan to implement discrete sampling using a
  combination of Gibbs and slice sampling but we haven't done so yet.
\item Stan has some distributions on covariance matrices that do not
  exist in \BUGS, including a uniform distribution over correlation
  matrices which may be rescaled, and the priors based on C-vines
  defined in \citep{LewandowskiKurowickaJoe:2009}.  In particular, the
  Lewandowski et al.\ prior allows the correlation matrix to be shrunk
  toward the unit matrix while the scales are given independent priors.
\item In \BUGS you need to define all variables.  In Stan, if you
  declare but don't define a parameter it implicitly has a flat prior
  (on the scale in which the parameter is defined).  For example, if
  you a parameters \code{p} declared as 
\begin{quote}
\begin{Verbatim}
real<lower=0, upper=1> p;
\end{Verbatim}
\end{quote}
%
and then have no sampling statement for \code{p} in the \code{model}
block, then you are implicitly assigning a uniform $[0,1]$ prior on
\code{p}.
On the other hand, if you have a parameter \code{theta} declared with
%
\begin{quote}
\begin{Verbatim}
real theta;
\end{Verbatim}
\end{quote}
%
and have no sampling statement for \code{theta} in the
\code{model} block, 
 then you are implicitly assigning an improper uniform prior
on $(-\infty,\infty)$ to \code{theta}.  
%
% Then if
% you define a transformed parameter \code{p} using
% \begin{quote}
% \begin{Verbatim} 
% p <- invlogit(theta);
% \end{Verbatim}
% \end{quote}
% %
% then you get a $\distro{Beta}(0,0)$ on \code{p}.
% then you are implicitly assigning an improper uniform
% (-infinity, infinity) prior on theta, which corresponds to a Beta
% (0,0) prior on p.  You could also assign this latter prior directly by
% defining p as the parameter and then writing the following within the
% model: p ~ beta (0, 0);
\item \BUGS models are always proper (being constructed as a product
  of proper marginal and conditional densities).  Stan models can be
  improper.  Here is the simplest improper Stan model: 
\begin{quote}
\begin{Verbatim}
parameters {
    real theta;
} 
model { }
\end{Verbatim}
\end{quote}
% \item You can also define some improper models in \BUGS directly, for
%   example, \Verb|p ~ beta (0, 0);| Remember how Stan works:
%   lines in the model are executables that correspond directly to
%   factors in the posterior density.  So you can define beta(0,0), it's
%   simply a mathematical function.  Stan doesn't "care" if it has a
%   finite integral.
\item Although parameters in Stan models may have improper priors, it
  is critical for the Hamiltonian simulations and NUTS sampler that
  the models have proper posteriors.  Improper posteriors can cause
  Stan to hang during warmup if adaptation is used (it is on by
  default) or during sampling if NUTS is used without a hard upper
  limit on Hamiltonian simulation steps.  At best, the sampler will
  drift and the chains will not mix well.  
\item
  As noted earlier, each statement in a Stan model is directly translated into the \Cpp code for computing the log posterior.  Thus, for example, the following pair of statements is legal in a Stan model:
\begin{quote}
\begin{Verbatim}
  y ~ normal(0,1);
  y ~ normal(2,3);
\end{Verbatim}
\end{quote}
%
The second line here does \emph{not} simply overwrite the first;
rather, \emph{both} statements contribute to the density function that
is evaluated.  The above two lines have the effect of including the
product, $\distro{Norm}(y|0,1) \times \distro{Norm}(y|2,3)$, into the
density function.
\\[6pt] 
For a perhaps more confusing example, consider the following two lines in a Stan model:
\begin{quote}
\begin{Verbatim}
  x ~ normal(0.8*y, sigma);
  y ~ normal(0.8*x, sigma);
\end{Verbatim}
\end{quote}
%
At first, this might look like a joint normal distribution with a
correlation of 0.8.  But it is not.  The above are \emph{not}
interpreted as conditional entities; rather, they are factors in the
joint density.  Multiplying them gives, $\distro{Norm}(x|0.8y,\sigma)
\times \distro{Norm}(y|0.8x,\sigma)$, which is what it is (you can
work out the algebra) but it is not the joint distribution where the
conditionals have regressions with slope 0.8.
%
\item With censoring and truncation, Stan uses the censored-data or
  truncated-data likelihood---this is not always done in \BUGS.  All
  of the approaches to censoring and truncation discussed in
  \citep{GelmanCarlinSternRubin:2003} and \citep{GelmanHill:2007} may
  be implemented in Stan directly as written.
%
\item Stan, like \BUGS, can benefit from human intervention in the
  form of reparameterization.  More on this topic to come.
  % For example, with the 8 schools: . . .
\end{itemize}

\section{Some Differences when Running from R}

\begin{itemize}

\item Stan can be set up from within R using two lines of code.
  Follow the instructions for running Stan from R on
  \url{http://mc-stan.org/}.  You don't need to separately download
  Stan and RStan.  Installing RStan will automatically set up Stan.
  When RStan moves to CRAN, it will get even easier.
\item In practice we typically run the same Stan model repeatedly.  If
  you pass RStan the result of a previously fitted model the model will 
  not need be recompiled. An example is given on the running
  Stan from R pages available from \code{http://mc-stan.org/}.
\item When you run Stan, it saves various conditions including
  starting values, some control variables for the tuning and running
  of the no-U-turn sampler, and the initial random seed. You can
  specify these values in the Stan call and thus achieve exact
  replication if desired.  (This can be useful for debugging.)
\item When running \BUGS from R, you need to send exactly the data
  that the model needs.  When running RStan, you can include extra
  data, which can be helpful when playing around with models.  For
  example, if you remove a variable \code{x} from the model, you can keep
  it in the data sent from R, thus allowing you to quickly alter the
  Stan model without having to also change the calling information in
  your R script.
\item As in R2WinBUGS and R2jags, after running the Stan model, you
  can quickly summarize using \code{plot()} and \code{print()}.  You
  can access the simulations themselves using various extractor
  functions, as described in the RStan documentation.  
\item Various information about the sampler, such as number of
  leapfrog steps, log probability, and step size, is available through
  extractor functions.   These can be useful for understanding what is
  going wrong when the algorithm is slow to converge.
\end{itemize}

\section{The Stan Community}

\begin{itemize}
\item Stan, like WinBUGS, OpenBUGS, and JAGS, has an active community,
  which you can access via the user's mailing list and the developer's
  mailing list; see \code{http://mc-stan.org/} for information on
  subscribing and posting and to look at archives.
\end{itemize}






% \chapter{User-Defined Functions and Gradients}\label{user-defined-functions.appendix}




