




\part{Commands and Data Formats}


\chapter{Compiling \Stan Programs 
to C++}\label{stanc.chapter}

Preparing a \Stan program to be run involves two compilation steps,
%
\begin{enumerate}
\item compiling the \Stan program to \Cpp, and
\item compiling the resulting \Cpp to an executable.
\end{enumerate}
%
This chapter discusses the first step; the second step is discussed in
\refchapter{compiling-cpp}.

\section{The \stanc Compiler}

The \stanc compiler converts \Stan programs to \Cpp programs.  

The first thing it does is parse the \Stan program.  If the parser is
successful, it then generates \Cpp code.  If the parser fails, it will
provide an error message indicating where and why the error occurred.

The following example illustrates a fully qualified call to \stanc.
%
\begin{verbatim}
> bin/stanc --name=binary_normal --o=binorm.cpp binormal.stan 
\end{verbatim}
%
This call specifies the name of the model, here {\tt binary\_normal}.
This will determine the name of the class implementing the model in
the \Cpp code.  The \Cpp code implementing the class is written to
\code{binorm.cpp}.  The final argument, \code{binormal.stan}, is
the file from which to read the \Stan program.


\section{Command-Line Options}

\begin{description}
%
\item[\tt {-}-help] 
\mbox{ } \\ 
Displays the manual page for \stanc.  If this option is selected,
nothing else is done.
%
\item[\tt {-}-version]
\mbox{ } \\ 
Prints the version of \stanc.  This is useful for bug reporting
and asking for help on the mailing lists.
%
\item[\tt {-}-name={\slshape class\_name}]
\mbox{ } \\ 
Specify the name of the class used for the implementation of the
\Stan model in the generated \Cpp code.  
\\[2pt]
Default: {\tt {\slshape class\_name = anon\_model}}
%
\item[\tt {-}-o={\slshape cpp\_file\_name}]
\mbox{ } \\ 
Specify the name of the file into which the generated \Cpp is written.
\\[2pt]
Default: {\tt {\slshape cpp\_file\_name} = {\slshape class\_name}.cpp}
%
\item[\tt {-}-no\_main]
\mbox{ } \\
Include this flag to prevent the generation of a main function in the
output.
\\[2pt]
Default: generate a main function
\end{description}





\chapter{Compiling C++ Programs}\label{compiling-cpp.chapter}

\Stan has been developed using two portable, open-source compilers,
\gpp and \clang, which run under Windows, Macintosh, and Unix/Linux.%
%
\footnote{As of the current version, \Stan cannot be compiled using
  \MSVC, the Windows-specific compiler from Microsoft.  \MSVC is able
  to compile the \code{stanc} compiler, but not the templates required
  for algorithmic differentiation and the Eigen matrix library.}
  

\section{Overview}

This section provides a complete example based on the \clang compiler
using optimizations; see the rest of the chapter for other compiler
options.

Suppose the \Cpp program for the model produced by \Stan resides in a
file called \code{my\_model.cpp} in the current working directory.
The following command will produce an executable in the file
\code{my\_model} in the current working directory.
%
\begin{quote}
\begin{Verbatim}
> g++ -I $stan/src -I $stan/lib my_model.cpp -o my_model
\end{Verbatim}
\end{quote}
%
In the command, \code{\$stan} is used to denote the path to the
top-level \Stan directory, which contains the \Cpp source code of the
\Stan library itself (in \code{\$stan/src}) as well as the libraries
on which it depends (in \code{\$stan/lib}).

\section{Which Compiler?}

It has been our experience that \clang is much faster to
compile at all optimization levels than \gpp, but that the executable
generated by \gpp is slightly faster to execute.

\section{What the Compiler Does}

A \Cpp compiler like \gpp or \clang actually performs several
lower-level operations in sequence,
% 
\begin{enumerate}
\item
parsing the input \Cpp source file(s), 
\item 
generating relocatable object code, and
\item 
linking the relocatable object code into executable code.
\end{enumerate}
%
These stages may be called separately, though the examples in
this manual perform them in a single call.


\section{Including Library Code}

\Stan is written as a set of header-only libraries.  This simplifies
writing code that uses \Stan.  The only thing that needs to be done
is to include the relevant libraries.  

The compiler command-line option to include a
header-only library is 
%
\begin{quote}
\code{-I {\slshape path-to-library}}.
\end{quote}
%
The path to the library must be such that any \code{\#include}
statements within the \Cpp source files be resolvable starting from
the path to the library.  

The header-only library code for \Stan itself is located in the
subdirectory \code{src/} of the top-level \Stan directory.  To allow
programs to use the \Stan library, the compiler needs to be given the
option 
%
\begin{quote}
\code{-I \$stan/src} 
\end{quote}
%
where \code{\$stan} is the path to the top-level \Stan directory.  If
the compiler is called from the top-level \Stan directory, it suffices
to use \code{-I src}, as in the examples in the first chapter.

\Stan depends on two open-source libraries,
%
\begin{enumerate}
\item Boost general purpose \Cpp libraries, and 
\item Eigen matrix and linear algebra \Cpp libraries
\end{enumerate}
%
These are both distributed along with \Stan in the directory
\code{\$stan/lib/}.  Both libraries take include paths starting under
\code{lib/}.  For most uses of \Stan, it is also necessary to include
an explicit compiler option to include Eigen and Boost,
%
\begin{quote}
\code{-I \$stan/lib}
\end{quote}
%
Thus calling \Stan typically requires all three of \Stan,
Boost, and Eigen to be included, which is accomplished with
%
\begin{quote}
\code{-I \$stan/lib -I {\slshape stan}/src}
\end{quote}
%

If the working directory is \code{\$stan}, the \code{\$stan/} prefix
may be eliminated from the calls.

\section{Compiler Optimization}

Stan was written with an optimizing compiler in mind.  For
that reason, it runs as much as an order of magnitude or more
faster with optimization turned on.  

For development, we recommend optimization level 0, whereas for
sampling, we recommend optimization level 3.  These are controlled
through the compiler option \code{-O} (capital letter `O').  To
generate efficient code, use
%
\begin{quote}
\code{-O3}
\end{quote}
%
where the first character is the capital letter `O'.
For faster compile time but less efficient code, use
%
\begin{quote}
\code{-O0}
\end{quote}
%
where the first character is the capital letter `O' and
the second character is the digit `0'.

\section{Executable Name}

If no name is provided for the executable, the default value of
\code{a.out} is used (\code{a.exe} on Windows).  This executable will
show up in the directory from which the compiler was called.

To put the executable in a different location, the \code{-o {\slshape
    path-to-executable}} command may be used.  In an earlier example,
\code{-o bern} was used to write the executable to a file called
\code{bern}.  (In Windows, executables are suffixed with \code{.exe}.)



\chapter{Running a \Stan Program}\label{stan-cmd.chapter}

Once a \Stan program defining a model has been converted to a \Cpp
program for that model (see \refchapter{stanc}) and the resulting \Cpp
program compiled to a platform-specific executable (see
\refchapter{compiling-cpp}), the model is ready to be run.

\section{Simple Example}

Suppose the executable is in file \code{mymodel} and the data
is in file \code{mydata}, both in the current working directory.
Then the \Stan executable may be run using
%
\begin{quote}
\begin{Verbatim}
> mymodel --data=mydata
\end{Verbatim}
\end{quote}
%
This will read the data from file \code{mydata}, run the default
fully-adaptive \NUTS sampler for 2000 iterations, discard the first
1000 iterations, writing the remainder to the file \code{samples.csv}
in the current working directory.  A random number generation seed
will be generated from the system time automatically.

\section{Command-Line Options}

The executable \Stan program is highly configurable.  At the highest
level, it may be configured for type of sampler (standard \HMC or \NUTS,
with or without step size adaptation), it may be provided with
data, initializations, a file to which to send the output, random
number generation seeds, etc.  

The full set of options is as follows.  The next section provides
some typical use-case examples.
%
\begin{description}
\cmdflag{help}
{Display help information including the command call and
  options.}
{default is not to display help information}
%
\cmdarg{data}{file}
{Read data from specified dump formatted
  file}
{required if model declares data}
%
\cmdarg{init}{file}
{Use initial values from specified file or zero
  values if <file>=0}
{default is random initialization}
%
\cmdarg{samples}{file}
{File into which samples are written}
{default = \code{samples.csv}}
%
\cmdflag{append\_samples}
{Append samples to existing file if it exists; do not print headers}
{default is to overwrite specified file}
%
\cmdarg{seed}{int}
{Random number generation seed}
{default is to randomly generate from time}
%
\cmdarg{chain\_id}{int}
{Markov chain identifier}
{default = \code{1}}
%
\cmdarg{iter}{+int}
{Total number of iterations, including warmup}
{default = \code{2000}}
%
\cmdarg{warmup}{+int}
{Discard the specified number of initial samples}
{default = \code{iter / 2}}
%
\cmdarg{thin}{+int}
{Period between saved samples after warm up}
{default = \code{max(1, floor(iter - warmup) / 1000)}}
%
\cmdarg{refresh}{+int}
{Period between samples updating progress report print}
{default = \code{max(1, iter / 200)}}
%
\cmdarg{leapfrog\_steps}{int}
{Number of leapfrog steps; \code{-1} for No-U-Turn adaptation}
{default = \code{-1}}
%
\cmdarg{max\_treedepth}{int}
{Limit \NUTS leapfrog steps to \code{pow(2,max\_tree\_depth)}; \code{-1} for no limit}
{default = \code{10}}
%
\cmdarg{epsilon}{float}
{Initial value for step size, or \code{-1} to set automatically}
{default = \code{-1}}
%
\cmdarg{epsilon}{[0,1]}
{Sample epsilon \code{+/- epsilon * epsilon\_pm}}
{default = \code{0.0}}
%
\cmdflag{epsilon\_adapt\_off}
{Turn off step size adaptation}
{step size adaptation is on by default}
%
\cmdarg{delta}{+float}
{Initial step size for step-size adaptation}
{default = \code{0.5}}
%
\cmdarg{gamma}{+float}
{Gamma parameter for dual averaging step-size adaptation}
{default = \code{0.05}}
%
\cmdflag{test\_grad}
{Test gradient calculations using finite differences; if this option
  is chosen, only the gradient tests are done.}
{default is not to test gradients}
%
\end{description}









\chapter{Dump Data Format}\label{dump.chapter}

For representing structured data in files, \Stan uses the dump format
introduced in \SPLUS and used in \R and \JAGS (and in \BUGS, but with
a different ordering).   A dump file is structured as a sequence of
variable definitions.  Each variable is defined in terms of its
dimensionality and its values.   There are three kinds of variable
declarations, one for scalars, one for sequences, and one for general
arrays.

\section{Scalar Variables}

A simple scalar value can be thought of as having an empty list of
dimensions.  Its declaration in the dump format follows the \SPLUS
assignment syntax.  For example, the following would constitute a
valid dump file defining a single scalar variable \code{y} with value
17.2.
%
\begin{quote}
\begin{Verbatim}
y <- 
17.2
\end{Verbatim}
\end{quote}
%
A scalar value is just a zero-dimensional array value.

\section{Sequence Variables}

One-dimensional arrays may be specified directly using the \SPLUS
sequence notation.  The following example defines an integer-value and
a real-valued sequence.
%
\begin{quote}
\begin{Verbatim}
n <- c(1,2,3)
y <- c(2.0,3.0,9.7)
\end{Verbatim}
\end{quote}
%
It is possible to define an array without a declaration of
dimensionality because the reader just counts the number of entries to
determine the size of the array.

\section{Array Variables}

For more than one dimension, the dump format uses a dimensionality
specification.  For example,
%
\begin{quote}
\begin{verbatim}
y <- structure(c(1,2,3,4,5,6), .Dim = c(2,3))
\end{verbatim}
\end{quote}
%
This defines a $2 \times 3$ array.  Data is stored in column-major
order, meaning the values for \code{y} will be as follows.
%
\begin{quote}
\begin{Verbatim}
y[1,1] = 1     y[2,1] = 3     y[3,1] = 5    
y[2,1] = 2     y[2,2] = 4     y[3,2] = 6
\end{Verbatim}
\end{quote}
%
The \code{structure} keyword just wraps a sequence of values and a
dimensionality declaration, which is itself just a sequence of
non-negative integer values.  The product of the dimensions must equal
the length of the array.


\section{Integer- and Real-Valued Variables}

There is no declaration in a dump file that distinguishes integer
versus real values.  If a value in a dump file's definition of a
variable contains a decimal point, \Stan assumes that the values are
real.  If there are no decimal points in a variable's defined value, 
the value may be assigned to variables declared as integer or real
in \Stan.

The following dump file declares an integer value for \code{y}.
%
\begin{quote}
\begin{Verbatim} 
y <- 
2
\end{Verbatim}
\end{quote}
% 
This definition can be used for a \Stan variable \code{y} declared as
\code{real} or as \code{int}.  Assigning an integer value to a real
variable automatically promotes the integer value to a real value.

The following dump file provides a real value for \code{y}.
%
\begin{quote}
\begin{Verbatim}
y <-
2.0
\end{Verbatim}
\end{quote}
%
Even though this is a round value, the occurrence of the decimal
point in the value, \code{2.0}, causes \Stan to infer that \code{y} is
real valued.  This dump file may only be used for variables \code{y}
declared as real in \Stan.


\section{Quoted Variable Names}

In order to support \JAGS data file, variables may be double quoted.
For instance, the following definition is legal in a dump file.
%
\begin{quote}
\begin{Verbatim}
"y" <-
c(1,2,3)
\end{Verbatim}
\end{quote}

\section{Line Breaks}

The line breaks in a dump file are required to be consistent with
the way \R reads in data.  Both of the following declarations are
legal.
%
\begin{quote}
\begin{Verbatim}
y <- 2
y <-
3
\end{Verbatim}
\end{quote}
%
Following its roots in \R, breaking before the assignment arrow is not
allowed.
%
\begin{quote}
\begin{Verbatim}
y
<- 2  # Syntax Error
\end{Verbatim}
\end{quote}

Lines may also be broken in the middle of sequences declared
using the \code{c(...)} notation., as well as between the comma
following a sequence definition and the dimensionality declaration.
For example, the following declaration of a $1 \times 2 \times 3$
array is valid.
%
\begin{quote}
\begin{Verbatim}
y <-
structure(c(1,2,3,
4,5,6,7,8,9,10,11,
12), .Dim = c(2,3,
4))
\end{Verbatim}
\end{quote}

\section{General R Sequence Syntax}

Sometimes, \R will use shorthand for its output. For example,
starting \R,

\begin{quote}
\begin{Verbatim}[fontshape=sl]
> R
\end{Verbatim}
\end{quote}
%
and then within \R, executing the following commands,

\begin{quote}
\begin{Verbatim}[fontshape=sl]
R> e <- matrix(c(1,2,3,4,5,6),nrow=2,ncol=3)
R> dump("e")
\end{Verbatim}
\end{quote}
%
leads to a \code{dumpdata.R} file being created with
the following contents.
%
\begin{quote}
\begin{Verbatim}
e <-
structure(c(1, 2, 3, 4, 5, 6), .Dim = 2:3)
\end{Verbatim}
\end{quote}
%
\R has used the fact that it allows a contiguous
sequence to be specified with its start and end point
using the notation \code{2:3}.  \Stan cannot currently
parse this format of input.  

Alternatively, \R is prone to include long-integer specifiers.
For instance, a $2 \times 2$ matrix is dumped as follows.
%
\begin{quote}
\begin{Verbatim}
f <-
structure(c(1, 2, 3, 4), .Dim = c(2L, 2L))
\end{Verbatim}
\end{quote}
%
Here the dimensions are defined to be \code{c(2L,~2L)}.  \Stan 
always treats these dimesions as \code{L}.

\subsection{How to Make R Behave?}

Currently, it is up to the user to munge the output of \R to a more
standardized format.  Over time, \Stan's reader will be improved to
deal with a wider range of output from \R's dump format.

Ben Goodrich suggests the following patch for binary cases:
%
\begin{quote}
\begin{Verbatim}
gsub("([1-9]):([1-9])", "c(\\1,\\2)", ".Dim = 3:4") 
# yields ".Dim = c(3,4)"
\end{Verbatim}
\end{quote}
%
Unfortunately, this won't be general enough if \R uses \code{2:4} for
\code{c(2,3,4)}.
