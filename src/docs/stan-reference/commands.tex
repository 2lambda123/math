




\part{Commands and Data Formats}


\chapter{Compiling \Stan Programs to C++}\label{stanc.chapter}

\noindent 
Preparing a \Stan program to be run involves two compilation steps,
%
\begin{enumerate}
\item compiling the \Stan program to \Cpp, and
\item compiling the resulting \Cpp to an executable.
\end{enumerate}

This chapter discusses the first step; the second step is discussed in
\refchapter{compiling-cpp}.

\section{The \stanc Compiler}

The \stanc compiler converts \Stan programs to \Cpp programs.  The
first stage of compilation involves parsing the text of the \Stan
program.  If the parser is successful, the second stage of compilation
generates \Cpp code.  If the parser fails, it will provide a
diagnostic error message indicating the location in the input where
the failure occurred and reason for the failure.

The following example illustrates a fully qualified call to \stanc.
%
\begin{quote}
\begin{Verbatim}[fontshape=sl]
> bin/stanc --name=binary_normal --o=binorm.cpp binormal.stan 
\end{Verbatim}
\end{quote}
%
This call specifies the name of the model, here {\tt binary\_normal}.
This will determine the name of the class implementing the model in
the \Cpp code.  Because this name is the name of a \Cpp class, it must
start with an alphabetic character (\code{a--z} or \code{A--Z}) and
contain only alphanumeric characters (\code{a--z}, \code{A--Z}, and
\code{0--9}) and underscores (\code{\_}) and should not conflict with
any \Cpp reserved keyword.  

The \Cpp code implementing the class is written to \code{binorm.cpp}.
The final argument, \code{binormal.stan}, is the file from which to
read the \Stan program.


\section{Command-Line Options}

\begin{description}
%
\item[\tt {-}-help] 
\mbox{ } \\ 
Displays the manual page for \stanc.  If this option is selected,
nothing else is done.
%
\item[\tt {-}-version]
\mbox{ } \\ 
Prints the version of \stanc.  This is useful for bug reporting
and asking for help on the mailing lists.
%
\item[\tt {-}-name={\slshape class\_name}]
\mbox{ } \\ 
Specify the name of the class used for the implementation of the
\Stan model in the generated \Cpp code.  
\\[2pt]
Default: {\tt {\slshape class\_name = anon\_model}}
%
\item[\tt {-}-o={\slshape cpp\_file\_name}]
\mbox{ } \\ 
Specify the name of the file into which the generated \Cpp is written.
\\[2pt]
Default: {\tt {\slshape cpp\_file\_name} = {\slshape class\_name}.cpp}
%
\item[\tt {-}-no\_main]
\mbox{ } \\
Include this flag to prevent the generation of a main function in the
output.
\\[2pt]
Default: generate a main function
\end{description}





\chapter{Compiling C++ Programs}\label{compiling-cpp.chapter}

\noindent
As shown in the previous chapter (\refchapter{stanc}), \Stan converts
a progam in the \Stan modeling language to a \Cpp program.  This \Cpp
program must then be compiled using a \Cpp compiler.  

\section{Which Compiler?}

\Stan has been developed using two portable, open-source \Cpp
compilers, \gpp and \clang, both of which run under and generate code
for Windows, Macintosh, and Unix/Linux.%
%
\footnote{As of the current version, \Stan cannot be compiled using
  \MSVC, the Windows-specific compiler from Microsoft.  \MSVC is able
  to compile the \code{stanc} compiler, but not the templates required
  for algorithmic differentiation and the Eigen matrix library.}

The \clang compiler is almost twice as fast at low levels of
optimization, but the machine code generated by \gpp is slightly
faster (around 10\% for \Stan) to execute.


\section{What the Compiler Does}

A \Cpp compiler like \gpp or \clang performs several lower-level
operations in sequence,
% 
\begin{enumerate}
\item
parsing the input \Cpp source file(s), 
\item 
generating relocatable object code, and
\item 
linking the relocatable object code into executable code.
\end{enumerate}
%
These stages may be called separately, though the examples in this
manual perform them in a single call.  The compiler invokes the
assembler to convert assembly language code to machine code, and the
linker to resolve the location of references in the relocatable object
files.

\section{Compiler Optimization}

\Stan was written with an optimizing compiler in mind, which allows
the code to be kept relatively clean and modular.  As a result, \Stan
code runs as much as an order of magnitude or more faster with
optimization turned on.

For development of \Cpp code for \Stan, use optimization level 0; for
sampling, use optimization level 3.  These are controlled through
\Stan's makefile using \code{O=0} and directly through \clang or \gpp
with \code{-O0}; in both cases, the first character is the letter `O'
and the second the digit `0'.


\section{Building the \Stan Library}

Before compiling a \Stan-generated \Cpp program, the \Stan object
library archive must be built using the makefile.  This only needs to
be done once and then the archive may be reused.  The recommended
build command for the \Stan archive is as follows.
%
\begin{quote}
\begin{Verbatim}[fontshape=sl]
> cd $stan
> make CC=g++ O=3 bin/libstan.a 
\end{Verbatim}
\end{quote} % $ -- dollar sign get highlighting unconfused in emacs!
%
Please be patient and ignore the (unused function) warning messages.
Compilation with high optimization on \code{g++} takes time (as much
as 10 minutes or more) and memory (a little over 3GB). 

This example uses the \code{g++} compiler for \Cpp (makefile option
\code{CC=g++}).  The \clang compiler may be used by specifying
\code{CC=clang++}.

This example uses compiler optimization level 3 (makefile option
\code{O=3}).  Turning the optimization level down to 0 allows the code
to built in under a minute in less than 1GB of memory.  This will slow
down sampling as much as an order of magnitude or more, so it is not
recommended for running models.  It can be useful for working on
\Stan's \Cpp code.


\section{Building a \Stan Model}

Suppose following the instructions in the last chapter
(\refchapter{stanc}) that a \Stan program has been converted to a \Cpp
program that resides in the source file \code{\$stan/my\_model.cpp}.

The following commands will produce an executable in the file
\code{my\_model} in the current working directory (\code{\$stan}).
%
\begin{quote}
\begin{Verbatim}[fontshape=sl]
> cd $stan
> g++ -O3 -Lbin -lstan -Isrc -Ilib my_model.cpp -o my_model
\end{Verbatim}
\end{quote} % $
%
The options used here are as follows.
\begin{quote}
\begin{description}
\item[\code{-O3}] sets optimization level 3,
\item[\code{-Lbin}] specifies that the archive is in the \code{bin}
  directory,
\item[\code{-lstan}] specifies the name of the archived library (not
  the name of the file in which it resides),
\item[\code{-Isrc}] specifies that the directory \code{src} should be
  searched for code (it contains the top-level \Stan headers),
\item[\code{-Ilib}] specifies the directory \code{lib} should be
  searched for code (it includes headers for libraries Eigen and
  Boost),
\item[\code{my\_model.cpp}] specifies the name of the source file to
  compile, and 
\item[\code{-o my\_model}] is the name of the resulting executable
  produced by the command (suffixed by \code{.exe} in Windows).
\end{description}
\end{quote}
%
The library binary and source specifications are required, as is the
name of the \Cpp file to compile.  User-supplied directories may be
included in header or archive form by specifying additional \code{-L},
\code{-l}, and \code{-I} options.
 
A lower optimization level may be specified.  If there is no
executable name specified using the \code{-o} option, then the model
is written into a file named \code{a.out}.
 

\section{Library Dependencies}

\Stan depends on two open-source libraries,
%
\begin{enumerate}
\item the Boost general purpose \Cpp libraries, and 
\item the Eigen matrix and linear algebra \Cpp libraries.
\end{enumerate}
%
These are both distributed along with \Stan in the directory
\code{\$stan/lib}.  

The code for \Stan itself is located in the directory
\code{\$stan/src}.  Because not all of \Stan is included in the
archive \code{bin/libstan.a}, the \code{src} directory must also be
included for compilation.




\chapter{Running a \Stan Program}\label{stan-cmd.chapter}

\noindent 
Once a \Stan program defining a model has been converted to a \Cpp
program for that model (see \refchapter{stanc}) and the resulting \Cpp
program compiled to a platform-specific executable (see
\refchapter{compiling-cpp}), the model is ready to be run.

\section{Simple Example}

Suppose the executable is in file \code{my\_model} and the data
is in file \code{my\_data}, both in the current working directory.
Then the \Stan executable may be run using
%
\begin{quote}
\begin{Verbatim}[fontshape=sl]
> my_model --data=my_data
\end{Verbatim}
\end{quote}
%
This will read the data from file \code{my\_data}, run warmup tuning for
1000 iterations, which are discarded, then run the fully-adaptive
\NUTS sampler for 1000 iterations, writing the parameter (and other)
values to the file \code{samples.csv} in the current working
directory.  A random number generation seed will be derived from
the system time automatically.

\section{Command-Line Options}

The executable \Stan program is highly configurable.  At the highest
level, it may be configured for type of sampler (standard \HMC or \NUTS,
with or without step size adaptation), it may be provided with
data, initializations, a file to which to send the output, random
number generation seeds, etc.  

The full set of options is as follows.  The next section provides
some typical use-case examples.
%
\begin{description}
\cmdflag{help}
{Display help information including the command call and
  options.}
{default is not to display help information}
%
\cmdarg{data}{file}
{Read data from specified dump formatted
  file}
{required if model declares data}
%
\cmdarg{init}{file}
{Use initial values from specified file or zero
  values if <file>=0}
{default is random initialization}
%
\cmdarg{samples}{file}
{File into which samples are written}
{default = \code{samples.csv}}
%
\cmdflag{append\_samples}
{Append samples to existing file if it exists; do not print headers}
{default is to overwrite specified file}
%
\cmdarg{seed}{int}
{Random number generation seed}
{default is to randomly generate from time}
%
\cmdarg{chain\_id}{int}
{Markov chain identifier}
{default = \code{1}}
%
\cmdarg{iter}{+int}
{Total number of iterations, including warmup}
{default = \code{2000}}
%
\cmdarg{warmup}{+int}
{Discard the specified number of initial samples}
{default = \code{iter / 2}}
%
\cmdarg{thin}{+int}
{Period between saved samples after warm up}
{default = \code{max(1, floor(iter - warmup) / 1000)}}
%
\cmdarg{refresh}{+int}
{Period between samples updating progress report print}
{default = \code{max(1, iter / 200)}}
%
\cmdflag{unit\_mass\_matrix}
{Use unit mass matrix for \NUTS; see related parameter \code{epsilon}}
{\NUTS default is to estimate a diagonal mass matrix}%
\footnote{Estimating a diagonal mass matrix is equivalent to 
estimating a stepsize for each parameter.}
%
\cmdarg{leapfrog\_steps}{int}
{Number of leapfrog steps; \code{-1} for No-U-Turn adaptation}
{default = \code{-1}}
%
\cmdarg{max\_treedepth}{int}
{Limit \NUTS leapfrog steps to \code{pow(2,max\_tree\_depth)}; \code{-1} for no limit}
{default = \code{10}}
%
\cmdarg{epsilon}{float}
{Initial value for step size, or \code{-1} to set automatically}
{default = \code{-1}}
%
\cmdarg{epsilon}{[0,1]}
{Sample epsilon \code{+/- epsilon * epsilon\_pm}; see related parameter \code{unit\_mass\_matrix}}
{default = \code{0.0}}
%
\cmdarg{delta}{+float}
{Initial step size for step-size adaptation}
{default = \code{0.5}}
%
\cmdarg{gamma}{+float}
{Gamma parameter for dual averaging step-size adaptation}
{default = \code{0.05}}
%
\cmdflag{test\_grad}
{Test gradient calculations using finite differences; if this option
  is chosen, only the gradient tests are done.}
{default is not to test gradients}
%
\end{description}

\section{Configuring the Sampler Type}

Which sampler gets used, standard \HMC or one of the two forms of
\NUTS, depends on the configuration of the command-line call.  The
following table summarizes.
%
\begin{center}
\begin{tabular}{l|ll}
{\it Sampler} & {\it Command Options}
\\ \hline \hline
\HMC & \Verb|--epsilon=e --leapfrog_steps=L| 
\\
\HMC + tuned step size & \Verb|--leapfrog_steps=L|
\\[8pt]
\NUTS & \Verb|--epsilon=e|
\\
\NUTS + tuned step size & \Verb|--diagonal_mass_matrix|
\\
\NUTS + tuned varying step sizes & (default configuration)
\end{tabular}
\end{center}
%
For an overview of Hamiltonian Monte Carlo (\HMC), see
\citep{Neal:2011}.  For details concerning the no-U-turn sampler
(\NUTS), see \citep{Hoffman-Gelman:2011,Hoffman-Gelman:2012}.






\chapter{Dump Data Format}\label{dump.chapter}

\noindent 
For representing structured data in files, \Stan uses the dump format
introduced in \SPLUS and used in \R and \JAGS (and in \BUGS, but with
a different ordering).   A dump file is structured as a sequence of
variable definitions.  Each variable is defined in terms of its
dimensionality and its values.   There are three kinds of variable
declarations, one for scalars, one for sequences, and one for general
arrays.

\section{Scalar Variables}

A simple scalar value can be thought of as having an empty list of
dimensions.  Its declaration in the dump format follows the \SPLUS
assignment syntax.  For example, the following would constitute a
valid dump file defining a single scalar variable \code{y} with value
17.2.
%
\begin{quote}
\begin{Verbatim}
y <- 
17.2
\end{Verbatim}
\end{quote}
%
A scalar value is just a zero-dimensional array value.

\section{Sequence Variables}

One-dimensional arrays may be specified directly using the \SPLUS
sequence notation.  The following example defines an integer-value and
a real-valued sequence.
%
\begin{quote}
\begin{Verbatim}
n <- c(1,2,3)
y <- c(2.0,3.0,9.7)
\end{Verbatim}
\end{quote}
%
Arrays are provided without a declaration of dimensionality because
the reader just counts the number of entries to determine the size of
the array.

Sequence variables may alternatively be represented with \R's
colon-based notation.  For instance, the first example above could
equivalently be written as
%
\begin{quote}
\begin{Verbatim} 
n <- 1:3
\end{Verbatim}
\end{quote}
% 
The sequence denoted by \code{1:3} is of length 3, running from 1 to 3
inclusive.  The colon notation allows sequences going from high to
low, as in the first of the following examples, which is equivalent to
the second.
%
\begin{quote}
\begin{Verbatim}
n <- 2:-2
n <- c(2,1,0,-1,-2)
\end{Verbatim}
\end{quote}
%


\section{Array Variables}

For more than one dimension, the dump format uses a dimensionality
specification.  For example,
%
\begin{quote}
\begin{verbatim}
y <- structure(c(1,2,3,4,5,6), .Dim = c(2,3))
\end{verbatim}
\end{quote}
%
This defines a $2 \times 3$ array.  Data is stored in column-major
order, meaning the values for \code{y} will be as follows.
%
\begin{quote}
\begin{Verbatim}
y[1,1] = 1     y[2,1] = 3     y[3,1] = 5    
y[2,1] = 2     y[2,2] = 4     y[3,2] = 6
\end{Verbatim}
\end{quote}
%
The \code{structure} keyword just wraps a sequence of values and a
dimensionality declaration, which is itself just a sequence of
non-negative integer values.  The product of the dimensions must equal
the length of the array.

If the dimensions happen to form a contiguous sequence of integers,
they may be written with colon notation.  Thus the example above is
equivalent to the following.
%
\begin{quote}
\begin{verbatim}
y <- structure(c(1,2,3,4,5,6), .Dim = 2:3)
\end{verbatim}
\end{quote}


\section{Integer- and Real-Valued Variables}

There is no declaration in a dump file that distinguishes integer
versus continuous values.  If a value in a dump file's definition of a
variable contains a decimal point, \Stan assumes that the values are
real.  

For a single value, if there is no decimal point, it may be assigned
to an \code{int} or \code{real} variable in \Stan.  An array value may
only be assigned to an \code{int} array if there is no decimal point
in any of the values.  This convention is compatible with the way \R
writes data.

The following dump file declares an integer value for \code{y}.
%
\begin{quote}
\begin{Verbatim} 
y <- 
2
\end{Verbatim}
\end{quote}
% 
This definition can be used for a \Stan variable \code{y} declared as
\code{real} or as \code{int}.  Assigning an integer value to a real
variable automatically promotes the integer value to a real value.

Integer values may optionally be followed by \code{L} or \code{l},
denoting long ineger values.  The following example, where the type is
explicit, is equivalent to the above.
%
\begin{quote}
\begin{Verbatim} 
y <- 
2L
\end{Verbatim}
\end{quote}

The following dump file provides a real value for \code{y}.
%
\begin{quote}
\begin{Verbatim}
y <-
2.0
\end{Verbatim}
\end{quote}
%
Even though this is a round value, the occurrence of the decimal
point in the value, \code{2.0}, causes \Stan to infer that \code{y} is
real valued.  This dump file may only be used for variables \code{y}
declared as real in \Stan.


\section{Quoted Variable Names}

In order to support \JAGS data files, variables may be double quoted.
For instance, the following definition is legal in a dump file.
%
\begin{quote}
\begin{Verbatim}
"y" <-
c(1,2,3)
\end{Verbatim}
\end{quote}

\section{Line Breaks}

The line breaks in a dump file are required to be consistent with
the way \R reads in data.  Both of the following declarations are
legal.
%
\begin{quote}
\begin{Verbatim}
y <- 2
y <-
3
\end{Verbatim}
\end{quote}
%
Also following \R, breaking before the assignment arrow are not
allowed, so the following is invalid.
%
\begin{quote}
\begin{Verbatim}
y
<- 2  # Syntax Error
\end{Verbatim}
\end{quote}

Lines may also be broken in the middle of sequences declared
using the \code{c(...)} notation., as well as between the comma
following a sequence definition and the dimensionality declaration.
For example, the following declaration of a $2 \times 2 \times 3$
array is valid.
%
\begin{quote}
\begin{Verbatim}
y <-
structure(c(1,2,3,
4,5,6,7,8,9,10,11,
12), .Dim = c(2,2,
3))
\end{Verbatim}
\end{quote}
%
Because there are no decimal points in the values, the resulting dump
file may be used for three-dimensional array variables declared as
\code{int} or \code{real}.




